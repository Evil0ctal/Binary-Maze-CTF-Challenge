# Deep Dive CTF Challenge - Binary Analysis

## Challenge Information

**Title**: Deep Dive

**Category**: Reverse Engineering

**Difficulty**: Hard

**Points**: 500

**Author**: [Evil0ctal](https://github.com/Evil0ctal/Binary-Maze-CTF-Challenge)

### Repository Information
- **GitHub**: [Binary-Maze-CTF-Challenge](https://github.com/Evil0ctal/Binary-Maze-CTF-Challenge)
- **License**: MIT
- **Version**: 1.0.0

### Description

A mysterious Python script has been discovered that appears to be generating some kind of encrypted binary file. The file contains multiple layers of protection and obfuscation, including anti-debugging mechanisms, code virtualization, and custom encryption. Your mission is to analyze the script, understand its internal workings, and recover the hidden flag.

### Challenge Files
- source.py - The obfuscated Python source code
- binary_maze (generated by the script)
- binary_maze.iv (generated by the script)

## Technical Deep Dive

### 1. Code Obfuscation Techniques

#### 1.1 Variable Obfuscation
```python
# Greek Letter Variables
λ = type('λ', (), {'δ': lambda x: eval(x)})()
Ω = lambda x: x if isinstance(x, str) else ''.join(chr(ord(c)) for c in str(x))
Σ = lambda x: bytes([ord(c)^42 for c in x])

# Single-character and Special Variables
μ = [0]*16
π = _______.mmap(-1, 4096)
θ = 0
```

#### 1.2 Control Flow Obfuscation
```python
def _α(self):
    while True:
        if self._δ():
            self._ε()
        ______.sleep(_____.random())

def _β(self, σ, τ):
    self.μ = [_____.randint(0, 0xFFFFFFFF) for _ in range(16)]
```

### 2. Anti-Debugging Mechanisms

#### 2.1 Time-based Detection
```python
def _δ(self):
    try:
        # Detect debugger through timing analysis
        return ______.time()-______.time() > 0.1
    except:
        return True
```

#### 2.2 Thread-based Protection
```python
self.γ = ________.Thread(target=self._α)
self.γ.daemon = True
self.γ.start()
```

### 3. Encryption Implementation

#### 3.1 Multi-layer XOR Encryption
```python
# Layer 1: Initial conversion
κ = [ord(c) for c in ζ]           # Convert string to ASCII values

# Layer 2: First XOR transformation
ι = [x ^ 42 for x in κ]           # XOR with constant 42

# Layer 3: Second XOR transformation
θ = [x ^ 0x55 for x in ι]         # XOR with constant 0x55

# Layer 4: Final XOR transformation
ρ = bytes([x ^ 0x33 for x in θ])  # XOR with constant 0x33
```

#### 3.2 AESGCM Encryption
```python
# Final encryption layer
σ = os.urandom(32)                # Generate random key
τ = AESGCM(σ)                     # Create AESGCM cipher
υ = os.urandom(12)                # Generate nonce
φ = τ.encrypt(υ, ρ, None)         # Encrypt data
```

## Solution Methodology

### 1. Static Analysis Phase

#### 1.1 Initial Code Review
```python
# Identify the main components
- Entry point (η function)
- Protection mechanisms (Δ class)
- Transformation logic (inside η)
```

#### 1.2 Pattern Recognition
```python
# Look for:
- XOR operations
- Byte transformations
- String operations
```

### 2. Dynamic Analysis Phase

#### 2.1 Debugging Bypass
```python
# Method 1: Patch time check
def _δ(self):
    return False

# Method 2: Remove threading
self.γ = None
```

#### 2.2 Data Flow Analysis
```python
# Add logging statements
print(f"Stage 1: {κ}")
print(f"Stage 2: {ι}")
print(f"Stage 3: {θ}")
print(f"Final: {ρ}")
```

### 3. Flag Recovery Process

#### 3.1 Manual Recovery
```python
def recover_flag(encrypted_data):
    # Reverse final XOR
    stage1 = bytes([x ^ 0x33 for x in encrypted_data])
    
    # Reverse second XOR
    stage2 = bytes([x ^ 0x55 for x in stage1])
    
    # Reverse first XOR
    stage3 = bytes([x ^ 42 for x in stage2])
    
    # Convert to string
    return ''.join(chr(x) for x in stage3)
```

#### 3.2 Automated Solution Script
```python
#!/usr/bin/env python3

def solve_challenge(filename):
    # Read encrypted data
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Reverse transformations
    return recover_flag(data)

if __name__ == "__main__":
    flag = solve_challenge("binary_maze")
    print(f"Recovered flag: {flag}")
```

## Advanced Topics

### 1. Code Virtualization

The challenge implements a basic form of code virtualization:
- Custom instruction set
- Virtual machine implementation
- State manipulation

### 2. Binary Protection

Multiple layers of binary protection are implemented:
- Anti-debugging checks
- Threading protection
- Memory manipulation
- Signal handlers

### 3. Code Obfuscation Analysis

Understanding the obfuscation techniques:
- Variable name obfuscation
- Control flow obfuscation
- Import obfuscation
- String encoding

## Learning Outcomes

Participants will learn:
1. Advanced Python code analysis
2. Anti-debugging technique bypassing
3. Multi-layer encryption analysis
4. Code deobfuscation strategies

## Additional Resources

### Tools
1. Python Debuggers
   - pdb
   - ipdb
   - PyCharm debugger

2. Analysis Tools
   - IDA Pro
   - Ghidra
   - Binary Ninja

### References
1. [Python Bytecode Analysis](https://docs.python.org/3/library/dis.html)
2. [Anti-Debugging Techniques](https://wiki.bi0s.in/reverse/anti-debugging/)
3. [Code Obfuscation Methods](https://en.wikipedia.org/wiki/Obfuscation_(software))

### Related CTF Challenges
1. Similar Python reverse engineering challenges
2. VM-based CTF problems
3. Anti-debug focused challenges

## Credits

Challenge designed and developed by [Evil0ctal](https://github.com/Evil0ctal).
Visit the [GitHub repository](https://github.com/Evil0ctal/Binary-Maze-CTF-Challenge) for more information.

*Note: This write-up is intended for educational purposes after the CTF competition has ended.*
